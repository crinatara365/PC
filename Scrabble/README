Tararache Crina-Andreea, ACS, CTI, grupa 314CB

Task0 - Pentru inceput, parcurg o matrice care reprezinta tabla de joc in cadrul careia am initializat toate pozitiile cu caracterul ".". La task0, am afisat aceasta matrice folosind functia data. Am ales sa scriu tot codul in main pentru ca mi s a parut mai logic. In functie de prima citire care este mereu numarul task-ului, programul va sti ce "if" sa compileze si sa ruleze.

Task1 - O sa explic la acest task citirea elementelor ca sa nu scriu de fiecare data. Cu ajutorul functiei fgets citim elemente de tip char pe care ulterior le transformam in numere prin intermediul functiei atoi. Astfel, pentru task1, citim numarul de cuvinte date. Pentru fiecare cuvant citit, citim, in aceasta ordine, coordonatele, directia, urmand ca in variabila p sa ramana cuvantul in sine. Apoi, in functie de valoarea lui D (1 sau 0), salvam cuvantul pe tabla de joc: primul caracter din p este pus pe pozitia indicata de coord X si Y, urmatoarele litere fiind trecute in matrice cu ajutorul unui for.

Task2 - Prima data am creat un vector in care am pus numarul de puncte aferent fiecarei litere din alfabet. La fel ca la task-ul precedent si la fel ca la urmatoarele, citim numarul de cuvinte, apoi citim fiecare cuvant in parte, si in sfarsit, parcurgem fiecare litera a fiecarui cuvant. Aflam pozitia literei in vectorul nostru si accea va fi valoarea adaugata la punctajul jucatorului. Verificam la ce linie suntem pentru a sti cui adaugam punctele. (linie para -> primul jucator; linie impara -> al doilea jucator)

Task3 - Spre deosebire de celalate task-uri acum citim si 2 string-uri pentru a determina daca avem sau nu bonus. Am ales sa atribui efectiv valorile in XX si YY pentru ca initial am folosit functia strcpy si nu a mers (cred eu) din cauza faptului ca am "\0" la finalul string-ului (a durat foarte mult sa-mi dau seama care este problema cu codul). Urmatorul pas este sa calculam punctajul jucatorilor fara punctele de bonus (copy paste de la task-ul 2). Apoi, pentru fiecare cuvant citit caut stringul XX in componenta cuvantului. Daca exista, in functie de D, ma deplasez pe orizontala sau verticala pentru a vedea cati de 1 gasesc in tabla de bonus pe pozitiile literelor din cuvantul meu. Retin acest numar intr-o variabila "a" pentru a sti de care ori inmultesc cu 2 punctajul pe care il am deja. De precizat faptul ca initial am folosit "^" care nu functiona cum trebuie, de aceea am folosit o structura repetitiva de tip while. Parcurg aceeasi pasi pentru stringul YY cu diferenta ca acesta trebuie sa se regaseasca in ultimele doua litere ale cuvantului. La final adaug la total puntajul W si T fie ca e obstinut cu bonus sau nu. De asemenea, resetez variabilele inaintea citirii urmatorului cuvant. 

Task4 - Cel mai complex lucru pe care l-am scris vreodata... Luam un vector de dimensiue suficient de mare pe care il umplem cu 0. Iau fiecare cuvant citit si il trec pe tabla de joc, pentru ca apoi sa compar cuvantul citit cu fiecare cuvant din vectorul words. Daca acesta se regaseste in vector, dau valoarea 1 pozitiei cuvantului in vectorul words. Mai pe scurt, in urma acestui for, in vectorul meu plin de 0, o sa am 1 pentru cuvintele din words deja utilizate pentru a sti sa nu le iau in calcul. Pe urma, parcurg vectorul meu v, de ficare data cand gasesc 0 (inseamna ca (,) cuvantul din words aferent pozitiei mele din v nu a fost folosit) retin in variabila "x" cuvantul din words. Pentru acesta, incep sa verific celelalte conditii. Mai intai, verific daca prima litera a cuvantul din x se afla pe tabla de joc. Daca acest lucru se intampla, verific daca cuvantul ar avea loc sa fie scris pe orizontala (sa nu depaseasca marginile tablei si sa nu se suprascrie peste alte litere). Daca nu este posibil, verific acest lucru pe verticala. Apoi, in functie de directia pe care se poate se scrie cuvantul, il trec pe tabla de joc. Daca nu se poate scrie pe nicio directie, se trece automat la urmatorul cuvantul. Oricum as scrie cuvantul, afisez matricea cu functia corespunzatoare si nu uit sa opresc programul cu "return 0" pentru ca odata gasit cuvantul cautat, nu am nevoie sa mai caute.

De la task-ul 5 incolo nu am mai facut fata. De asemenea, se regasesc comentarii in cod pentru a exprima cat mai bine ce am lucrat.